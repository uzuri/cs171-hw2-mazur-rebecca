1. 
	1. Contribution Calendar:  This would be a useful tool for PMs or other managers (whose teams use GitHub) when looking for performance metrics -- how often has this person been contributing, when -- with the gotcha that the person being alanlyzed didn't have to be contributing to the projects that you think are important!  That data isn't shown.  This makes a specifc call to contributions_calendar_data, which I'm having a bit of difficulty finding in the documetnation of the API but know you can get through a GET on the div's data URL (per the HW document).  For this one, the extremely productive day scenerio doesn't affect much -- the fellow will have a particularly green square.  Now unfortunately that square probably won't be any greener than a moderately productive day, so it might be worth while to make the scale used for deciding color more dynamic (so greenest is always most, rather than cut-off point, which seems to be where it is now).  On the other hand, it may well be that the cutoff point is the best way to represent an extremely productive day, as the extended scale would make other, moderately productive days looks like nothing!  It may well be that "did more than the average bear" is all that's important here.
	
	2. Contributers:  This tells us a lot about the life of a project, including a breakdown of who's really keeping it alive.  This can be useful for people wanting to use a project -- you want something that's fairly lively (exception: when a project has reached stability and maturity -- this kind of graph can give the wrong idea there) and also most likely something where the activity is spread out among many contributors!  This appears to just be calling for commits and their timestamps (curl https://api.github.com/repos/:owner/:repo/commits).  The extremely productive day scenerio gives you a huge spike here and pushes the scale so that more normal days might look like everyone was slacking off (this is a real issue with this sort of graph; I know we have problems with it in Google Analytics when we have news spikes on our website -- you have to filter out the spiking page to get a better overview).  The breakdown graphs already help a little with this -- you can at least see where the spike came from and understand that it was one person going a little nuts.  What might be even better would be to be able to view just a portion of the main graph (like you can with the people graphs) so as to exclude the spike if you need to.  Also the ability to cut an individual out of the herd -- to see the main graph without them -- might be useful when  you need to see "normal" activity without the spikes.
	
	3. Commits Activity: This one's a little harder to see the use and audience for.  The main graph still gives you a feel for the "life" of a project, so it can still be useful for someone interested in seeing if using said project is for them.  Day of the week commits could, I suppose, be useful to a PM (let's see if people are saving everything up until Friday or something).  This, too, seems to just be processing the commits/dates (curl https://api.github.com/repos/:owner/:repo/commits), in this case just for the project.  The extremely productive day again gives us spikes that seem to skew the graph -- being able to filter a portion of the main graph for viewing (and adjusting the scale when doing so) would help with that.
	
	4. Code Frequency:  This graph is probably most useful for the developers themselves (or a really clueless PM who thinks that LOC or similar is the most important metric and would freak at the red lines).  It gives a good feel for whether the commits are abotu adding feature (more lines added than removed), cleaning up code (more lines removed than added) or just tweaking bugs (most likely equal distribution, though it could lean one way or the other if it's a biggie).  There is specifically an API call for code frequency (curl https://api.github.com/repos/:owner/:repo/stats/code_frequency) so this is an easy, one-call operation, too.  An extremely productive day might well not affect this graph, unless the person was really ripping the code apart (it's possible to make a ton of commits without much real change).  But if said contributor was really whaling on the codebase, it could affect the graph.  The real problem would be that you lose the clarity of additions vs. removal if someone's making a ton of changes -- most likely they're making a lot of different sorts of changes, which probably gives you a mush of adds and removes and no clear picture of what they were actually doing.  The ability to dive down to commit-level adds and removes would clarify this (this is weekly level right now), though I don't think the API has anything in it that would support doing so.
	
	5. Punch Card:  This is another management-targeted one.  You can see when your team is doing their work (the d3 guys are all either nightowls or not in this timezone; I clearly do my best work in the early afternoon, except for one wild pitch at 9:00 pm on HW1).  There's a special API call for this one, too (curl https://api.github.com/repos/:owner/:repo/stats/punch_card) that puts everything in one call.   Because this is actualyl averaged over a long period of time, the extremely productive day scenerio is unlikely to affect it much.  It might drastically inflate one of the bubbles if it were more an extremely productive hour scenerio, but even then it's fighting heavy averaging over time.  If it did become an issue, though, being able to specify the time span over which to show the activity would again clarify things and allow the user to iron out spikes.
	
	6. Pulse: This gives you a snapshot of current activity -- again, good for determining if this is a project that's alive enough for you to consider using.  It pulls data from a couple places, inclyding commits (curl https://api.github.com/repos/:owner/:repo/commits),  issues (curl https://api.github.com/issues), pull requests (curl https://api.github.com/repos/:owner/:repo/pulls), additions/deletions (curl https://api.github.com/repos/:owner/:repo/stats/punch_card), and comments (curl https://api.github.com/repos/:owner/:repo/pulls/comments).  So a lot going on here.  Because of the way this is presented, as a slice in time, an extremely productive day just looks like exactly that -- lots of activity.  Since that's what you want to see here in that case, there's not much harm in it.    It would make for a long content page if a lot of issues were closed, but otherwise wouldn't do much to affect the usefuless of the graphs.  

	7. Network Graph: I think this visualization is most useful for contributors and PMs (who are also contributors) for understanding the structure of the existing repository.  I /believe/ its using Get all References in the API to be able to get all the information it needs (curl https://api.github.com/repos/:owner/:repo/git/trees/:sha), but it may also need some of the get a tree tools, though I'm not clear on that.   An extremely productive day might lengthen the graph annoyingly, but it's not the end of the world, thanks to the scrolling.  Given that this graph *must* directly reflect the repository structure to be accurate, I wouldn't attempt to do anything that would filter the extremely productive day -- I can't see that being useful.  Instead, I think I'd implement some sort of jump-to tool so that you wouldn't have to scroll past all the commits (and then probably cut off the uber-committer's caffeine supply, but that's neither here nor there). The interactivity gives you the ability to get details on the various graph nodes -- this is actually the most important part of this thing, otherwise it's just a pretty picture.  Now this could be done statically (labels always visible), but your graph is going to be cluttered really, really fast and it's going to be hard to see what's pointing to what.  So showing the labels on request is a good usability tactic.  I don't think an influx of developers would be much worse than the extremely productive day scenerio (really, they're the same thing, just one has many people and the other few).  If they're all following good development practice and using branches appropriately, we might want to make it easier to pick out a branch -- I noticed that this was an issue after looking at a very large project; sometimes you have a merge of a branch hanging way off in the middle of nowhere; it might be useful to be able to swap "closeness" of branches so that you have the branches you're most interested in next to each other rather than a vertical scroll or two away.  Lots of contributors tend to make that branch problem happen more often.  