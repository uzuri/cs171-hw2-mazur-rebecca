<!DOCTYPE html>
<meta charset="utf-8">
<title>Homework 2 Graph</title>
<style>
  .link {
    stroke-width: 1.5px;
  }

  .node {
    fill: #66CC66;
    stroke: #000;
    stroke-width: 1px;
  }

  .node:hover {
    fill: red;
  }

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
  <!--<form>
Layout:
<label><input type="radio" name="layout" value="force"> Force</label>
<label><input type="radio" name="layout" value="random" > Random</label>
<label><input type="radio" name="layout" value="radial"> Radial</label>
<label><input type="radio" name="layout" value="line" checked> Line</label>
<label><input type="radio" name="layout" value="line_cat"> Line by Category</label>
</form>-->
  <!--<form>
Color:
<label><input type="radio" name="color" value="nocolor" checked> None</label>
<label><input type="radio" name="color" value="color_cat" > Category</label>
</form>-->
  <!--<form>
Size:
<label><input type="radio" name="size" value="nosize" checked> None</label>
<label><input type="radio" name="size" value="size_cat" > Category</label>
</form>-->
  <form>
  Axis:
    <label><input type="radio" name="axis" value="index" checked> Indexed</label>
    <label><input type="radio" name="axis" value="time" > Time</label>
  </form>
<script>

d3.json("json/master.json", function(error, data1)
{
d3.json("json/box-animation.json", function(error, data2)
{
d3.json("json/collection.disperse.json", function(error, data3)
{
d3.json("json/do-not-recreate-destroyed-models.json", function(error, data4)
{
d3.json("json/fix.viewCollection.remove.json", function(error, data5)
{
d3.json("json/master-old.json", function(error, data6)
{
d3.json("json/next.json", function(error, data7)
{
d3.json("json/ns.router.generateUrl.json", function(error, data8)
{
d3.json("json/stub.json", function(error, data9)
{
d3.json("json/mixins.json", function(error, data10)
{
                                  
	var data = new Array();
	
	for (j = 0; j < data1.length; j++)
	{	
		data1[j].rawcat = "master";
		data.push(data1[j]);	
	}
	for (j = 0; j < data2.length; j++)
	{	
		data2[j].rawcat = "box-animation";
		data.push(data2[j]);	
	}
	for (j = 0; j < data3.length; j++)
	{	
		data3[j].rawcat = "collection.disperse";
		data.push(data3[j]);	
	}
	for (j = 0; j < data4.length; j++)
	{	
		data4[j].rawcat = "do-not-recreate-destroyed-models";
		data.push(data4[j]);	
	}
	for (j = 0; j < data5.length; j++)
	{	
		data5[j].rawcat = "fix.viewCollection.remove";
		data.push(data5[j]);	
	}
	for (j = 0; j < data6.length; j++)
	{	
		data6[j].rawcat = "master-old";
		data.push(data6[j]);	
	}
	for (j = 0; j < data10.length; j++)
	{	
		data10[j].rawcat = "mixins";
		data.push(data10[j]);	
	}
	for (j = 0; j < data7.length; j++)
	{	
		data7[j].rawcat = "next";
		data.push(data7[j]);	
	}
	for (j = 0; j < data8.length; j++)
	{	
		data8[j].rawcat = "ns.router.generateUrl";
		data.push(data8[j]);	
	}
	for (j = 0; j < data9.length; j++)
	{	
		data9[j].rawcat = "stub";
		data.push(data9[j]);	
	}
	                   
	data.sort(function(a, b) 
	{
		return d3.descending(a.commit.committer.date, b.commit.committer.date);
	});
	
	var width = 1200,
		height = 400,
		margin = 20,
		leftpadding = 200
		margintop = 50;
	
	var svg = d3.select("body")
		.append("svg")
		.attr("width", width)
		.attr("height", height);
	
	var fill = d3.scale.category10();
	
	// Scales
	
	var indexScale = d3.scale.linear().range([0 + leftpadding, width - margin - leftpadding]);
	indexScale.domain([data.length, 0]);
	
	
	var timeScale = d3.time.scale().range([0 + leftpadding, width - margin - leftpadding]);
	var max = d3.max(data, function(d) {
		var splitdate = d.commit.author.date.split("");
		return new Date(splitdate[0] + splitdate[1] + splitdate[2] + splitdate[3], splitdate[5] + splitdate[6], splitdate[8] + splitdate[9], splitdate[11] + splitdate[12], splitdate[14] + splitdate[15], splitdate[17] + splitdate[18]);
	});
	
	var min = d3.min(data, function(d) {
		var splitdate = d.commit.author.date.split("");
		return new Date(splitdate[0] + splitdate[1] + splitdate[2] + splitdate[3], splitdate[5] + splitdate[6], splitdate[8] + splitdate[9], splitdate[11] + splitdate[12], splitdate[14] + splitdate[15], splitdate[17] + splitdate[18]);
	});
	
	timeScale.domain([min, max]);
	
	
	
	
	var catScale = d3.scale.ordinal().rangeRoundBands([0, 10], 0, 0);
	var tree = function(d) { 
		return d.rawcat; 
	};
	catScale.domain(data.map(tree));
	
	// Axes
	var xAxis = d3.svg.axis().scale(timeScale).orient("bottom");
	
	// Graph
	
	var graph = {nodes:[], links:[]};
	
	graph.nodes = data;
	
	graph.nodes.map(function(d, i) {
		graph.nodes.map(function(e, j) {
			d.cat = catScale(d.rawcat);
			for (counter = 0; counter < d.parents.length; counter++)
			{
				if (d.parents[counter].sha == e.sha)
				{
					graph.links.push({"source": i, "target": j})
				}
			}
		})
	});
	
	
	// Generate the force layout
	var force = d3.layout.force()
		.size([width, height])
		.charge(-50)
		.linkDistance(10)
		.on("tick", tick)
		.on("start", function(d) {})
		.on("end", function(d) {})
	
	var tick = function(d) 
	{
		graph_update(0);
	}
	
	function random_layout() {
	
	force.stop();
	
	graph.nodes.forEach(function(d, i) {
		d.x = width/4 + 2*width*Math.random()/4;
		d.y = height/4 + 2*height*Math.random()/4;
	})
	
	graph_update(500);
	}
	
	function force_layout() {
	
		force.nodes(graph.nodes)
		.links(graph.links)
		.start();
	}
	
	function line_layout() {
		force.stop();
		
		graph.nodes.forEach(function(d, i) {
			d.y = 0;
			d.x = indexScale(i);
		})
	
		graph_update(0);
	}
	
	function line_cat_layout() {
	
		force.stop();
		
		graph.nodes.forEach(function(d, i) {
			d.y = margintop + d.cat*10;
			d.x = indexScale(i);
		})
		
		graph_update(0);
	}
	
	function radial_layout() {
	
		force.stop();
		
		var r = height/2;
		
		var arc = d3.svg.arc()
			.outerRadius(r);
		
		var pie = d3.layout.pie()
			.sort(function(a, b) { return a.cat - b.cat;})
			.value(function(d, i) { return 1; }); // equal share for each point
		
		graph.nodes = pie(graph.nodes).map(function(d, i) {
			d.innerRadius = 0;
			d.outerRadius = r;
			d.data.x = arc.centroid(d)[0]+height/2;
			d.data.y = arc.centroid(d)[1]+width/2;
			d.data.endAngle = d.endAngle;
			d.data.startAngle = d.startAngle;
			return d.data;
		})
		
		graph_update(500);
	}
	
	
	function category_color() {
		d3.selectAll("circle")
			.transition()
			.duration(500)
			.style("fill", function(d) { return fill(d.cat); });
	}
	
	function category_size() {
		d3.selectAll("circle")
			.transition()
			.duration(500)
			.attr("r", 0);
	}
	
	function graph_update(delay) {
		link.transition()
			.duration(delay)
			.attr("fill", "none")
			.attr("d", function(d) {
				return "M" + d.target.x + " " + d.target.y + " q" + 0 + " " + (d.source.y - d.target.y) + " " + (d.source.x - d.target.x) + " " + (d.source.y - d.target.y)
			});
		
		node.transition()
			.duration(delay)
			.attr("transform", function(d) {
				return "translate("+d.x+","+d.y+")";
			});
	}
	
	var link = svg.selectAll(".link")
		.data(graph.links)
		.enter()
		.append("path")
		.attr("class", "link")
		.attr("marker-end", "url(#end)")
		.attr("stroke", function(d) {
			return fill(data[d.source].cat); 
		});
	
	var node = svg.selectAll(".node")
		.data(graph.nodes)
		.enter()
		.append("g")
		.attr("class", function(d) {
			return "cat" + d.cat + " node";
		});
	
	node.append("circle").attr("r", 0);
	
		
		
	svg.append("g").attr("id", "xaxis").call(xAxis);
		
	force_layout();
	line_cat_layout();
	category_color();
});
});
});
});
});
});
});
});
});
});

</script>
</body>
</html>
